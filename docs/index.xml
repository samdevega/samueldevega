<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Samuel de Vega</title>
    <link>https://www.samueldevega.com/</link>
    <description>Recent content on Samuel de Vega</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-es</language>
    <lastBuildDate>Sun, 10 Oct 2021 13:45:42 +0100</lastBuildDate><atom:link href="https://www.samueldevega.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Object Oriented Pills Depende del comportamiento, no de los datos</title>
      <link>https://www.samueldevega.com/posts/object-oriented-pills-depende-del-comportamiento-no-de-los-datos/</link>
      <pubDate>Sun, 10 Oct 2021 13:45:42 +0100</pubDate>
      
      <guid>https://www.samueldevega.com/posts/object-oriented-pills-depende-del-comportamiento-no-de-los-datos/</guid>
      <description>Al programar, se puede caer en la tentación de utilizar variables para almacenar el resultado de la llamada a un método determinado. Esto es particularmente delicado cuando un método habla sobre la lógica de la aplicación.
Contexto Supongamos un formulario de acceso, el cual se compone de un email, una contraseña y el correspondiente botón de envío.
Para este punto de la aplicación se han definido las siguientes reglas:
 El email debe ser estructuralmente válido.</description>
    </item>
    
    <item>
      <title>Object Oriented Pills: Polimorfismo procedural</title>
      <link>https://www.samueldevega.com/posts/object-oriented-pills-polimorfismo-procedural/</link>
      <pubDate>Fri, 12 Mar 2021 09:00:44 +0000</pubDate>
      
      <guid>https://www.samueldevega.com/posts/object-oriented-pills-polimorfismo-procedural/</guid>
      <description>Sobre el polimorfismo en el diseño orientado a objetos Cuando hablamos de polimorfismo, nos referimos a que objetos de distintas clases sean capaces de responder a mensajes sintácticamente iguales (misma firma) independientemente de su comportamiento interno. Dependiendo del lenguaje en el que nos encontremos el polimorfismo se implementará de una forma determinada, como puede ser mediante interfaces.
Un ejemplo sencillo puede ser la respuesta a preguntar por su área a objetos cuyas clases representan las figuras geométricas de un círculo, un cuadrado y un triángulo:</description>
    </item>
    
    <item>
      <title>Sobre mí</title>
      <link>https://www.samueldevega.com/sobre-mi/</link>
      <pubDate>Wed, 27 Jan 2021 18:02:43 +0000</pubDate>
      
      <guid>https://www.samueldevega.com/sobre-mi/</guid>
      <description>.photo-container { border: 3px solid #e8eef2; border-radius: 50%; height: 150px; margin: 0 auto; overflow: hidden; position: relative; width: 150px; } .photo-color { position: absolute; } .photo-monochrome { opacity: 100%; position: absolute; transition: all ease-in-out 0.3s; } .photo-monochrome:hover { opacity: 0; }   Soy originario de Las Palmas de Gran Canaria y me dedico al desarrollo de software multiplataforma.
Me defino como alguien autodidacta, con afán de superación, creativo, proactivo, asertivo y siempre encantado de trabajar en equipo.</description>
    </item>
    
    <item>
      <title>Design Principles: Cohesión, acoplamiento y encapsulamiento</title>
      <link>https://www.samueldevega.com/posts/design-principles-cohesion-acoplamiento-y-encapsulamiento/</link>
      <pubDate>Sun, 23 Jun 2019 09:51:33 +0000</pubDate>
      
      <guid>https://www.samueldevega.com/posts/design-principles-cohesion-acoplamiento-y-encapsulamiento/</guid>
      <description>Cohesión En el diseño orientado a objetos, se entiende por cohesión (cohesion en inglés) al grado en el que los distintos elementos de un módulo se mantienen unidos a dicho módulo. Es decir, aquellos elementos que pueden entenderse como parte de un concepto que los engloba, deberían estar dentro de este y no dispersos en otros módulos.
Los elementos convergen hacia su propio módulo y son conocidos y usados sólo por este</description>
    </item>
    
    <item>
      <title>Bad Smells: Clases Librería</title>
      <link>https://www.samueldevega.com/posts/bad-smells-clases-libreria/</link>
      <pubDate>Wed, 20 Mar 2019 18:44:47 +0000</pubDate>
      
      <guid>https://www.samueldevega.com/posts/bad-smells-clases-libreria/</guid>
      <description>Introducción Una aplicación moderna utilizará clases librería. En ocasiones estas nos ponen en un dilema. Queremos que la librería sea diferente, pero no queremos cambiarla. Incluso cuando es posible cambiar de librería, conlleva riesgos: Afecta a otros clientes y ello implica rehacer nuestros cambios para futuras versiones de la librería.
Incomplete Library Class Síntomas Estás utilizando una librería y hay una característica que te gustaría que tuviese.
Qué hacer  Contactar con el creador para ver si puede incorporar la característica.</description>
    </item>
    
    <item>
      <title>Bad Smells: Alojando el cambio</title>
      <link>https://www.samueldevega.com/posts/bad-smells-alojando-el-cambio/</link>
      <pubDate>Wed, 20 Mar 2019 17:31:25 +0000</pubDate>
      
      <guid>https://www.samueldevega.com/posts/bad-smells-alojando-el-cambio/</guid>
      <description>Introducción Algunos problemas se vuelven más aparentes cuando intentas cambiar el código. Lo ideal es que una decisión de cambio afecte sólo a un único lugar. Cuando esto no sucede, es una señal de duplicidad de código. Detectar estos problemas suele tener otros beneficios como facilitar la testeabilidad del código.
Los malos olores relativos al cambio simultáneo forzado entre clases son:
 Divergent Change Shotgun Surgery Parallel Inheritance Hierarchies Combinatorial Explosion  Divergent Change Síntomas Una misma clase necesita cambiar por diferentes motivos.</description>
    </item>
    
    <item>
      <title>Bad Smells: Responsabilidad</title>
      <link>https://www.samueldevega.com/posts/bad-smells-responsabilidad/</link>
      <pubDate>Wed, 20 Mar 2019 15:02:42 +0000</pubDate>
      
      <guid>https://www.samueldevega.com/posts/bad-smells-responsabilidad/</guid>
      <description>Introducción El equilibrio en la responsabilidad entre objetos es difícil de conseguir. Una de las virtudes de la refactorización es que nos permite experimentar con diferentes ideas de una forma segura y nos permite cambiar de idea.
Hay herramientas que nos ayudan a decidir como trabajan los objetos entre sí, como los patrones de diseño o las cartas CRC.
Las refactorizaciones suelen ser reversibles y pueden compensar dos opciones.
Los malos olores que pueden aparecer por una mala separación de las responsabilidades son:</description>
    </item>
    
    <item>
      <title>Bad Smells: Herencia</title>
      <link>https://www.samueldevega.com/posts/bad-smells-herencia/</link>
      <pubDate>Wed, 20 Mar 2019 12:47:12 +0000</pubDate>
      
      <guid>https://www.samueldevega.com/posts/bad-smells-herencia/</guid>
      <description>Introducción La relación entre una clase y su subclase suele comenzar siendo simple pero se va volviendo más complicada con el paso del tiempo. Una subclase a menudo depende de su generalización más estrechamente que una clase ajena, pero esto puede ser demasiado.
La clave es decidir entre lo que una clase es y lo que una clase tiene. La estructura de una clase suele comenzar con herencia y con el paso del tiempo se mueve más hacia la composición.</description>
    </item>
    
    <item>
      <title>Bad Smells: Datos</title>
      <link>https://www.samueldevega.com/posts/bad-smells-datos/</link>
      <pubDate>Wed, 20 Mar 2019 08:09:48 +0000</pubDate>
      
      <guid>https://www.samueldevega.com/posts/bad-smells-datos/</guid>
      <description>Introducción Los DTOs son una oportunidad. Si los datos forman un buen conjunto, normalmente podemos encontrar un comportamiento que pertenezca a la clase.
Los malos olores resultantes de un mal uso de las estructuras de datos son:
 Primitive Obsession Data Class Data Clump  Primitive Obsession Síntomas  Uso de primitivos o casi primitivos (int, float, String, etc.). Constantes y enumeraciones representando pequeños enteros. Constantes de tipo String representando nombres de campos.</description>
    </item>
    
    <item>
      <title>Bad Smells: Lógica condicional</title>
      <link>https://www.samueldevega.com/posts/bad-smells-logica-condicional/</link>
      <pubDate>Tue, 19 Mar 2019 21:46:06 +0000</pubDate>
      
      <guid>https://www.samueldevega.com/posts/bad-smells-logica-condicional/</guid>
      <description>Introducción  Es difícil de razonar ya que tenemos que considerar múltiples caminos a través del código. Es tentador añadir casos de uso especiales en lugar de desarrollar un caso de uso general. A veces es usada como un mal sustituto de mecanismos orientados a objetos.  Los malos olores derivados de un mal uso de la lógica condicional son:
 Null Check Complicated Boolean Expression Special Case Simulated Inheritance (Switch Statement)  Null Check Qué hacer  Si hay un valor por defecto razonable, utilizalo.</description>
    </item>
    
  </channel>
</rss>
